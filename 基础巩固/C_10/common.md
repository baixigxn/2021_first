# 题目：

题目：输入两个正整数m和n，求其最大公约数和最小公倍数



### **算法分析**：

##### 辗转相除法

辗转相除法是古希腊求两个正整数的最大公约数的算法，也叫欧几里德算法，其方法是用较大的数除以较小的数，上面较小的除数和得出的余数构成新的一对数，继续做上面的除法，直到出现能够整除的两个数，其中较小的数（即除数）就是最大公约数。以求136和93的最大公约数为例，操作如下：

168/93=1 ……75

93/75=1……18

75/18=4……3

18/3=6

所以3就是168和93的最大公约数

##### 遍历法



### 主要代码(辗转相除法)

```c
void fun(int m,int n){
    int a,b,t;
  	if(m<n){//先将较大的数放到m里面
        t=m;
        m=n;
        n=t;
    }
    a=m;
    b=n;//让a等于较大的数，让b等于较小的数
    while(b!=0){//利用辗转相除法，直到余数b为零结束
        t=a%b;
        a=b;
        b=t;
    }
    printf("最大公约数是：%d\n",a);
    printf("最小公倍数是：%d\n",m*n/b);
}
```



### 主要代码（遍历法）

```c
void fun2(int m,int n){
	int x=1,y;//最大公约数x设置为1,最小公倍数y
    int min,max;
    int i;
    
    min=m>n?n:m;
    max=m>n?m:n;
    
    if(max%min==0){//两个数是倍数关系
        printf("最大公约数：%d\n最小公倍数：%d\n",min,max);
    } else{//不成倍数
		//寻找最大公约数
        for(i=1;i<=min;i++){//从1找到min
            if(max%i==0 && min%i==0) x=i;
        }
        while(max%m!=0 || max%n!=0){//当有一方不能被整除时，继续往后找
            max++;
        }
        y=max;
        printf("最大公约数：%d\n最小公倍数：%d\n",x,y);
    }
}
```



### 今日巩固

1. 辗转相除法（欧几里德算法）的学习和使用
2. 对于两个数的换位置，可以使用昨天刚巩固的条件运算符的使用
3. while循环与for循环的区别与使用